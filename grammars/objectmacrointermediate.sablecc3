/* This file is part of SableCC ( http://sablecc.org ).
 *
 * See the NOTICE file distributed with this work for copyright information.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Package org.sablecc.objectmacro.intermediate.syntax3;

Helpers
    any = [0..0xffff];
    string_char = [any - [[''' + '\'] + [10 + 13]]];

Tokens
    macro_kw = 'Macro';
    param_kw = 'Param';
    param_insert_kw = 'ParamInsert';
    internal_kw = 'Internal';
    directive_kw = 'Directive';
    name_kw = 'Name';
    macro_ref_kw = 'MacroRef';
    type_kw = 'Type';
    eol_kw = 'eol';
    insert_kw = 'Insert';
    value_kw = 'Value';
    args_kw = 'Args';
    macro_insert_kw = 'MacroInsert';
    var_kw = 'Var';
    macro_body_kw = 'MacroBody';

    l_brace = '{';
    r_brace = '}';
    assign = '=';
    blank = (' ' | 13 | 10)+;
    string_kw = 'String';
    string = ''' (string_char | '\' ''' | '\\')* ''';
    semicolon = ';';
    comma = ',';

Ignored Tokens
    blank;

Productions

    intermediate_representation
        =
            [macros]:macro*
        ;

    macro
        =
            macro_kw l_brace name [params]:param* macro_body r_brace
                {-> New macro(name.string, [params], [macro_body.macro_parts])};

    macro_body
            {-> [macro_parts]:macro_part*}
        =
            macro_body_kw l_brace [macro_parts]:macro_part* r_brace
                {-> [macro_parts]};

    param
        =
            {param} param_kw l_brace name type directives? r_brace
                {-> New param.param(name.string, type, [directives.directives])} |
            {internal} internal_kw l_brace name type directives? r_brace
                {-> New param.internal(name.string, type, [directives.directives])}
        ;

    directives
            {-> [directives]:directive*}
        =
            directive [additional_directives]:additional_directive*
                {-> [directive, additional_directives.directive]}
        ;

    additional_directive
                {-> directive}
        =
            comma directive
                {-> directive}
        ;

    type
        =
            {string} type_kw assign string_kw
                {-> New type.string(string_kw)}
        |
            {macro_refs} type_kw l_brace [macro_refs]:macro_ref* r_brace
                {-> New type.macro_refs([macro_refs])}
        ;

    directive
        =
            directive_kw l_brace name value r_brace
                {-> New directive(name.string, value)}
        ;

    macro_ref
        =
            {identifier} macro_ref_kw l_brace name args? r_brace
                {-> New macro_ref(name.string, [args.values])}
        ;

    args
            {-> [values]:value*}
        =
            args_kw l_brace values r_brace
                {-> [values.values]}
        ;

    values
            {-> [values]:value*}
        =
            value [additional_values]:additional_value*
                {-> [value, additional_values.value]}
        ;

    additional_value
            {-> value}
        =
            comma value
                {-> value}
        ;

    value
        =
            {var} var_kw assign string
                {-> New value.var(string)}
        |
            {string} value_kw l_brace [text_parts]:text_part+ r_brace
                {-> New value.string([text_parts])}
        ;

    name
            {-> string}
        =
            name_kw assign string
                {-> string}
        ;

    macro_part
            {-> macro_part }
        =
            {string} string semicolon
                {-> New macro_part.string(string)}
        |
            {eol} eol_kw semicolon
                {-> New macro_part.eol()}
        |
            {var} param_insert semicolon
                {-> New macro_part.var(param_insert.string)}
        |
            {insert} macro_insert semicolon
                {-> New macro_part.insert(macro_insert.macro_ref)}
        ;

    macro_insert
            {-> macro_ref}
        =
            macro_insert_kw l_brace macro_ref r_brace
                {-> macro_ref}
        ;

    text_part
            {-> text_part }
        =
            {string} string semicolon
                {-> New text_part.string(string)}
        |
            {var} param_insert semicolon
                {-> New text_part.var(param_insert.string)}
        |
            {insert} macro_insert semicolon
                {-> New text_part.insert(macro_insert.macro_ref)}
        |
            {eol} eol_kw semicolon
                {-> New text_part.eol()}
        ;

    param_insert
            {-> string}
        =
            param_insert_kw assign string
                {-> string}
        ;

Abstract Syntax Tree

    intermediate_representation
        =
            [macros]:macro*
        ;

    macro =
        [name]:string [params]:param* [macro_parts]:macro_part*;

    param =
        {param} [name]:string type [directives]:directive* |
        {internal} [name]:string type [directives]:directive*;

    type =
        {string} string_kw |
        {macro_refs} macro_ref*;

    directive =
        [name]:string value;

    macro_ref =
        string [args]:value*;

    value =
        {var} [name]:string |
        {string} [parts]:text_part+;

    macro_part =
        {string} string |
        {eol} |
        {var} [name]:string |
        {insert} macro_ref;

    text_part =
        {string} string |
        {var} [name]:string |
        {insert} macro_ref |
        {eol} ;
